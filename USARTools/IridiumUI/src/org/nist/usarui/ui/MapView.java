/*****************************************************************************
  DISCLAIMER:
  This software was produced in part by the National Institute of Standards
  and Technology (NIST), an agency of the U.S. government, and by statute is
  not subject to copyright in the United States.  Recipients of this software
  assume all responsibility associated with its operation, modification,
  maintenance, and subsequent redistribution.
*****************************************************************************/

package org.nist.usarui.ui;

import org.nist.usarui.Utils;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.util.*;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;

/**
 * Allows maps generated by time traces of position (INS, GroundTruth, GPS) sensors to be shown
 * in a 2D overhead view. View can be zoomed and panned as necessary.
 *
 * @author Stephen Carlson (NIST)
 */
public class MapView extends View {
	/**
	 * The background color for the map.
	 */
	public static final Color MAP_BG = new Color(192, 192, 192);
	/**
	 * The maximum number of points that can be stored before the map starts deleting old ones.
	 */
	public static final int MAX_POINTS = 1000;
	/**
	 * Colors used for painting range finder data. After the 4th range finder, it will cycle.
	 */
	public static final Color[] RANGE_COLOR = new Color[] {
		new Color(255, 0, 0, 127), new Color(0, 255, 0, 127),
		new Color(0, 0, 255, 127), new Color(255, 255, 0, 127)
	};
	/**
	 * The resolution of the map; coordinates must be this far apart (in m) to be logged.
	 */
	public static final double RES = 0.05;
	/**
	 * One meter in simulation equals this many pixels on the map by default.
	 */
	public static final double SCALE = 50.;

	/**
	 * Robot's little icon shape.
	 */
	private final Polygon botIcon;
	/**
	 * The center of the map in screen coordinates.
	 */
	private final Point center;
	/**
	 * Maps range sensor names to their appropriate colors.
	 */
	private final Map<String, Integer> colorMap;
	/**
	 * The last color index handed out.
	 */
	private volatile int lastColor;
	/**
	 * The coordinates at which the mouse was last seen when dragging started.
	 */
	private Point lastDrag;
	/**
	 * The point where the robot was last seen.
	 */
	private Point2D lastPoint;
	/**
	 * The path taken to the point. It is conceivable that this could overflow on a really,
	 * really long run; but this is a utility, right?
	 */
	private final List<Point2D> path;
	/**
	 * Data stored from the range scanner.
	 */
	private RangeData ranges;
	/**
	 * Component which draws the map.
	 */
	private final MapRenderer renderer;
	/**
	 * The current zoom factor.
	 */
	private double scalar;
	/**
	 * Rotation of the robot icon on screen in radians.
	 */
	private double theta;

	/**
	 * Creates a new attached map view.
	 *
	 * @param title the map title
	 * @param parent the parent that contains this window
	 */
	public MapView(Component parent, String title) {
		super(parent, title);
		MouseInputAdapter listener = new MouseInputAdapter() {
			public void mouseDragged(MouseEvent e) {
				if (lastDrag == null)
					lastDrag = new Point(e.getX(), e.getY());
				else {
					// Find deltas and move center
					int dx = lastDrag.x - e.getX(), dy = e.getY() - lastDrag.y;
					if (dx != 0 || dy != 0) {
						center.setLocation(center.x + dx, center.y + dy);
						lastDrag.setLocation(e.getX(), e.getY());
						renderer.repaint();
					}
				}
			}
			public void mouseReleased(MouseEvent e) {
				lastDrag = null;
			}
			public void mouseWheelMoved(MouseWheelEvent e) {
				double newScale = scalar;
				// Zoom in or out by 10% each time
				if (e.getUnitsToScroll() > 0)
					newScale /= 1.1;
				else
					newScale *= 1.1;
				// Limit zoom from 10 px/m to 100 px/m (big range!)
				newScale = Math.min(Math.max(newScale, 10.), 100.);
				// Fix center location to avoid disorientation
				center.x = (int)Math.round(center.x * newScale / scalar);
				center.y = (int)Math.round(center.y * newScale / scalar);
				scalar = newScale;
				renderer.repaint();
			}
		};
		// Load bot icon (triangle facing up)
		botIcon	= new Polygon(new int[] { 4, 0, -4, 0 }, new int[] { 5, -5, 5, 3 }, 4);
		center = new Point(0, 0);
		colorMap = new HashMap<String, Integer>(8);
		// Prepare renderer
		renderer = new MapRenderer();
		renderer.addMouseMotionListener(listener);
		renderer.addMouseListener(listener);
		renderer.addMouseWheelListener(listener);
		dialog.getContentPane().add(renderer);
		// Initialize variables
		lastColor = 0;
		lastDrag = null;
		lastPoint = null;
		path = new LinkedList<Point2D>();
		ranges = null;
		scalar = SCALE;
		theta = 0.;
	}
	/**
	 * Displays range scanner data on the ground truth map.
	 *
	 * @param data range data from the sensor
	 * @param res the sensor resolution in radians
	 * @param fov the sensor field of view in radians
	 * @param name the name of the range scanner
	 */
	public void addRangeData(float[] data, float res, float fov, String name) {
		int index;
		synchronized (colorMap) {
			if (colorMap.containsKey(name))
				index = colorMap.get(name);
			else {
				colorMap.put(name, lastColor);
				index = lastColor;
				lastColor = (lastColor + 1) % RANGE_COLOR.length;
			}
		}
		ranges = new RangeData(data, fov, res, RANGE_COLOR[index]);
		renderer.repaint();
	}
	/**
	 * Rounds the point coordinate to the nearest integer coordinate.
	 *
	 * @param point the point to display
	 * @return the point turned into the nearest integer
	 */
	private int round(double point) {
		return (int)Math.round(point * scalar);
	}
	/**
	 * Sets the pose of the on-screen robot to the specified coordinate.
	 *
	 * @param x the x coordinate (where x is N/S on the screen)
	 * @param y the y coordinate (where y is E/W on the screen)
	 * @param theta the robot's heading in rads, where 0 is N
	 */
	@SuppressWarnings( "SuspiciousNameCombination" )
	public void setPose(double x, double y, double theta) {
		boolean newPoint = true;
		// Check if point is new
		if (lastPoint == null)
			lastPoint = new Point2D.Double(y, -x);
		else if (lastPoint.distanceSq(y, -x) > RES * RES)
			lastPoint.setLocation(y, -x);
		else
			newPoint = false;
		// If necessary, add point to path and delete oldest to make room
		if (newPoint)
			synchronized (path) {
				path.add(new Point2D.Double(y, -x));
				if (path.size() > MAX_POINTS)
					path.remove(0);
			}
		// Always redraw
		this.theta = theta;
		renderer.repaint();
	}

	/**
	 * Represents data from a range finder sensor.
	 */
	private static class RangeData {
		private final Color color;
		private final GeneralPath poly;

		/**
		 * Creates a new set of range data.
		 *
		 * @param data the data to show
		 * @param fov the sensor's field of view in radians
		 * @param resolution the sensor's resolution in radians
		 * @param color the color to paint the data
		 */
		private RangeData(float[] data, float fov, float resolution, Color color) {
			float heading = (float)(fov - Math.PI) / 2.f;
			this.color = color;
			// Trace outline of the scanned area
			poly = new GeneralPath();
			poly.moveTo(0.f, 0.f);
			for (float value : data) {
				poly.lineTo(value * Utils.fCos(heading), value * Utils.fSin(heading));
				heading -= resolution;
			}
			poly.closePath();
		}
		public void paint(Graphics2D g) {
			// Already assumes that the position, antialias, heading, etc. is right
			g.setColor(color);
			g.fill(poly);
		}
	}

	/**
	 * Renders the map on-screen.
	 */
	private class MapRenderer extends JComponent {
		/**
		 * The back-buffer for painting.
		 */
		private Image buffer;
		/**
		 * The last size of the component. If it differs, the buffer is remade.
		 */
		private Dimension last;

		/**
		 * Creates an empty map renderer.
		 */
		public MapRenderer() {
			buffer = null;
			last = null;
			setFont(new Font("Courier New", Font.PLAIN, 8));
		}
		/**
		 * Allocates an image buffer of the specified size.
		 *
		 * @param size the buffer size to create (stored in instance variable)
		 */
		private void allocateBuffer(Dimension size) {
			if (buffer == null || last == null || !last.equals(size)) {
				last = size;
				buffer = createImage(size.width, size.height);
			}
		}
		public void paint(Graphics g) {
			final Dimension size = getSize(); Point2D lastPoint = null;
			final int gridStep = (int)Math.round(scalar),
				cX = gridStep * (center.x / gridStep), cY = -gridStep * (center.y / gridStep);
			allocateBuffer(size);
			// This shouldn't take too long...
			Graphics2D bg = (Graphics2D)buffer.getGraphics();
			bg.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
			bg.setColor(MAP_BG);
			bg.fillRect(0, 0, size.width, size.height);
			Graphics2D ig = (Graphics2D)bg.create();
			// Move to user location
			ig.translate(size.width / 2, size.height / 2);
			ig.translate(-center.x, center.y);
			// Render meter grid
			ig.setColor(Color.GRAY);
			for (int x = 0; x < size.width; x += gridStep) {
				ig.drawLine(cX + x, cY - size.height, cX + x, cY + size.height);
				ig.drawLine(cX - x, cY - size.height, cX - x, cY + size.height);
			}
			for (int y = 0; y < size.height; y += gridStep) {
				ig.drawLine(cX - size.width, cY + y, cX + size.width, cY + y);
				ig.drawLine(cX - size.width, cY - y, cX + size.width, cY - y);
			}
			// Render axes
			ig.setColor(Color.RED);
			ig.drawLine(0, cY - size.height, 0, cY + size.height);
			ig.setColor(Color.GREEN);
			ig.drawLine(cX - size.width, 0, cX + size.width, 0);
			// Render path
			ig.setColor(Color.BLUE);
			synchronized (path) {
				for (Point2D point : path) {
					// Draw line from point to last point
					if (lastPoint != null)
						ig.drawLine(round(lastPoint.getX()), round(lastPoint.getY()),
							round(point.getX()), round(point.getY()));
					lastPoint = point;
				}
			}
			// Render robot icon
			if (lastPoint != null) {
				ig.setColor(Color.BLACK);
				ig.translate(round(lastPoint.getX()), round(lastPoint.getY()));
				ig.rotate(theta);
				ig.fill(botIcon);
				// Render range
				if (ranges != null) {
					ig.scale(scalar, scalar);
					ranges.paint(ig);
				}
			}
			ig.dispose();
			// Draw compass rose
			bg.setColor(Color.RED);
			bg.drawLine(20, 8, 20, 32);
			bg.setColor(Color.GREEN);
			bg.drawLine(8, 20, 32, 20);
			bg.setColor(Color.BLUE);
			bg.drawString("N", 8, 12);
			bg.dispose();
			// Render back-buffer now
			g.drawImage(buffer, 0, 0, null);
		}
		public void update(Graphics g) {
			paint(g);
		}
	}
}