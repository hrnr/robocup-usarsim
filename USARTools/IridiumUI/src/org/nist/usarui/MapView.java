/*****************************************************************************
  DISCLAIMER:
  This software was produced in part by the National Institute of Standards
  and Technology (NIST), an agency of the U.S. government, and by statute is
  not subject to copyright in the United States.  Recipients of this software
  assume all responsibility associated with its operation, modification,
  maintenance, and subsequent redistribution.
*****************************************************************************/

package org.nist.usarui;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.util.*;
import java.util.List;
import javax.swing.*;
import javax.swing.event.*;

/**
 * Allows maps generated by time traces of position (INS, GroundTruth, GPS) sensors to be shown
 * in a 2D overhead view. View can be zoomed and panned as necessary.
 *
 * @author Stephen Carlson (NIST)
 */
public class MapView extends View {
	/**
	 * The background color for the map.
	 */
	public static final Color MAP_BG = new Color(192, 192, 192);
	/**
	 * The maximum number of points that can be stored before the map starts deleting old ones.
	 */
	public static final int MAX_POINTS = 1000;
	/**
	 * The resolution of the map; coordinates must be this far apart (in m) to be logged.
	 */
	public static final double RES = 0.05;
	/**
	 * One meter in simulation equals this many pixels on the map by default.
	 */
	public static final double SCALE = 50.;

	/**
	 * Robot's little icon shape.
	 */
	private final Polygon botIcon;
	/**
	 * The center of the map in screen coordinates.
	 */
	private final Point center;
	/**
	 * The coordinates at which the mouse was last seen when dragging started.
	 */
	private Point lastDrag;
	/**
	 * The point where the robot was last seen.
	 */
	private Point2D lastPoint;
	/**
	 * The path taken to the point. It is conceivable that this could overflow on a really,
	 * really long run; but this is a utility, right?
	 */
	private final List<Point2D> path;
	/**
	 * Component which draws the map.
	 */
	private final MapRenderer renderer;
	/**
	 * The current zoom factor.
	 */
	private double scalar;
	/**
	 * Rotation of the robot icon on screen in radians.
	 */
	private double theta;

	/**
	 * Creates a new attached map view.
	 *
	 * @param title the map title
	 * @param parent the parent that contains this window
	 */
	public MapView(Component parent, String title) {
		super(parent, title);
		MouseInputAdapter listener = new MouseInputAdapter() {
			public void mouseDragged(MouseEvent e) {
				if (lastDrag == null)
					lastDrag = new Point(e.getX(), e.getY());
				else {
					// Find deltas and move center
					int dx = lastDrag.x - e.getX(), dy = e.getY() - lastDrag.y;
					if (dx != 0 || dy != 0) {
						center.setLocation(center.x + dx, center.y + dy);
						lastDrag.setLocation(e.getX(), e.getY());
						renderer.repaint();
					}
				}
			}
			public void mouseReleased(MouseEvent e) {
				lastDrag = null;
			}
			public void mouseWheelMoved(MouseWheelEvent e) {
				double newScale = scalar;
				// Zoom in or out by 10% each time
				if (e.getUnitsToScroll() > 0)
					newScale /= 1.1;
				else
					newScale *= 1.1;
				// Limit zoom from 10 px/m to 100 px/m (big range!)
				newScale = Math.min(Math.max(newScale, 10.), 100.);
				// Fix center location to avoid disorientation
				center.x = (int)Math.round(center.x * newScale / scalar);
				center.y = (int)Math.round(center.y * newScale / scalar);
				scalar = newScale;
				renderer.repaint();
			}
		};
		// Load bot icon (triangle facing up)
		botIcon	= new Polygon(new int[] { 4, 0, -4, 0 }, new int[] { 5, -5, 5, 3 }, 4);
		center = new Point(0, 0);
		// Prepare renderer
		renderer = new MapRenderer();
		renderer.addMouseMotionListener(listener);
		renderer.addMouseListener(listener);
		renderer.addMouseWheelListener(listener);
		dialog.getContentPane().add(renderer);
		// Initialize variables
		lastDrag = null;
		lastPoint = null;
		path = new LinkedList<Point2D>();
		scalar = SCALE;
		theta = 0.;
	}
	/**
	 * Sets the pose of the on-screen robot to the specified coordinate.
	 *
	 * @param x the x coordinate (where x is N/S on the screen)
	 * @param y the y coordinate (where y is E/W on the screen)
	 * @param theta the robot's heading in rads, where 0 is N
	 */
	@SuppressWarnings( "SuspiciousNameCombination" )
	public void setPose(double x, double y, double theta) {
		boolean newPoint = true;
		// Check if point is new
		if (lastPoint == null)
			lastPoint = new Point2D.Double(y, -x);
		else if (lastPoint.distanceSq(y, -x) > RES * RES)
			lastPoint.setLocation(y, -x);
		else
			newPoint = false;
		// If necessary, add point to path and delete oldest to make room
		if (newPoint)
			synchronized (path) {
				path.add(new Point2D.Double(y, -x));
				if (path.size() > MAX_POINTS)
					path.remove(0);
			}
		// Always redraw
		this.theta = theta;
		renderer.repaint();
	}

	/**
	 * Renders the map on-screen.
	 */
	private class MapRenderer extends JComponent {
		/**
		 * The back-buffer for painting.
		 */
		private Image buffer;
		/**
		 * The last size of the component. If it differs, the buffer is remade.
		 */
		private Dimension last;

		/**
		 * Creates an empty map renderer.
		 */
		public MapRenderer() {
			buffer = null;
			last = null;
			setFont(new Font("Courier New", Font.PLAIN, 8));
		}
		/**
		 * Allocates an image buffer of the specified size.
		 *
		 * @param size the buffer size to create (stored in instance variable)
		 */
		private void allocateBuffer(Dimension size) {
			if (buffer == null || last == null || !last.equals(size)) {
				last = size;
				buffer = createImage(size.width, size.height);
			}
		}
		public void paint(Graphics g) {
			final Dimension size = getSize(); Point2D lastPoint = null;
			final int gridStep = (int)Math.round(scalar),
				cX = gridStep * (center.x / gridStep), cY = -gridStep * (center.y / gridStep);
			allocateBuffer(size);
			// This shouldn't take too long...
			Graphics2D bg = (Graphics2D)buffer.getGraphics();
			bg.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
			bg.setColor(MAP_BG);
			bg.fillRect(0, 0, size.width, size.height);
			Graphics2D ig = (Graphics2D)bg.create();
			// Move to user location
			ig.translate(size.width / 2, size.height / 2);
			ig.translate(-center.x, center.y);
			// Render meter grid
			ig.setColor(Color.GRAY);
			for (int x = 0; x < size.width; x += gridStep) {
				ig.drawLine(cX + x, cY - size.height, cX + x, cY + size.height);
				ig.drawLine(cX - x, cY - size.height, cX - x, cY + size.height);
			}
			for (int y = 0; y < size.height; y += gridStep) {
				ig.drawLine(cX - size.width, cY + y, cX + size.width, cY + y);
				ig.drawLine(cX - size.width, cY - y, cX + size.width, cY - y);
			}
			// Render axes
			ig.setColor(Color.RED);
			ig.drawLine(0, cY - size.height, 0, cY + size.height);
			ig.setColor(Color.GREEN);
			ig.drawLine(cX - size.width, 0, cX + size.width, 0);
			// Render path
			ig.setColor(Color.BLUE);
			synchronized (path) {
				for (Point2D point : path) {
					// Draw line from point to last point
					if (lastPoint != null)
						ig.drawLine(round(lastPoint.getX()), round(lastPoint.getY()),
							round(point.getX()), round(point.getY()));
					lastPoint = point;
				}
			}
			// Render robot icon
			if (lastPoint != null) {
				ig.setColor(Color.BLACK);
				ig.translate(round(lastPoint.getX()), round(lastPoint.getY()));
				ig.rotate(theta);
				ig.fill(botIcon);
			}
			ig.dispose();
			// Draw compass rose
			bg.setColor(Color.RED);
			bg.drawLine(20, 8, 20, 32);
			bg.setColor(Color.GREEN);
			bg.drawLine(8, 20, 32, 20);
			bg.setColor(Color.BLUE);
			bg.drawString("N", 8, 12);
			bg.dispose();
			// Render back-buffer now
			g.drawImage(buffer, 0, 0, null);
		}
		/**
		 * Rounds the point coordinate to the nearest integer coordinate.
		 *
		 * @param point the point to display
		 * @return the point turned into the nearest integer
		 */
		private int round(double point) {
			return (int)Math.round(point * scalar);
		}
		public void update(Graphics g) {
			paint(g);
		}
	}
}